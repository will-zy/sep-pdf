<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Separador e Agrupador de PDF por Nome</title>
     ZF
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-100 p-4 sm:p-6 md:p-8">
    <div class="max-w-2xl mx-auto mt-10 bg-white p-6 rounded-lg shadow-md">
         Aplicação 
        <div class="mb-4">
            <h1 class="font-bold text-2xl mb-2">PDF por Nome</h1>
            <p class="text-slate-600">Esta ferramenta usa um rótulo (ex: "Gestor:") para encontrar um nome e agrupa todas as ocorrências daquele nome em um único PDF.</p>
        </div>

        <div class="space-y-4 mb-6">
            <div>
                <label for="pdfFile" class="block text-sm font-medium text-slate-700 mb-1">1. Selecione o arquivo PDF:</label>
                <input type="file" id="pdfFile" accept=".pdf" class="block w-full text-sm text-slate-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700
                    hover:file:bg-blue-100 cursor-pointer">
            </div>

            <div>
                <label for="labels" class="block text-sm font-medium text-slate-700 mb-1">2. Rótulos de busca (separados por vírgula):</label>
                <input type="text" id="labels" value="Gestor:,Supervisor:,Responsável:" placeholder="Gestor:,Supervisor:,Responsável:"
                    class="mt-1 block w-full rounded-md border-slate-300 shadow-sm p-2
                    focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
            </div>

            <div class="flex items-center space-x-2">
                <input type="checkbox" id="headerOnly" class="h-4 w-4 text-blue-600 border-slate-300 rounded focus:ring-blue-500">
                <label for="headerOnly" class="text-sm font-medium text-slate-700">Procurar somente no cabeçalho</label>
            </div>
        </div>

        <div>
            <button id="processBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md
                transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Processar e Agrupar por Nome
            </button>
        </div>
    </div>

    <div id="loader" class="hidden mt-4 text-center text-blue-600 font-medium">
        <span class="animate-spin inline-block w-5 h-5 border-2 border-current border-t-transparent rounded-full mr-2"></span>
        Processando... Por favor, aguarde.
    </div>

    <h2 class="text-xl font-bold mt-8 mb-2 text-slate-800 max-w-2xl mx-auto">Log de Processamento</h2>
    <div class="max-w-2xl mx-auto bg-slate-50 border border-slate-200 rounded-md p-4 overflow-auto max-h-60">
        <pre id="log" class="font-mono text-sm whitespace-pre-wrap break-words">Aguardando arquivo para processar...</pre>
    </div>

    <script src="./lib/pdf-lib.min.js"></script>
    <script type="module">
        import * as pdfjsLib from './lib/pdf.mjs';
        pdfjsLib.GlobalWorkerOptions.workerSrc = './lib/pdf.worker.mjs';

        const pdfFileInput = document.getElementById('pdfFile');
        const labelsInput = document.getElementById('labels');
        const headerOnlyCheckbox = document.getElementById('headerOnly');
        const processBtn = document.getElementById('processBtn');
        const logOutput = document.getElementById('log');
        const loader = document.getElementById('loader');

        const HEADER_BOTTOM_Y_PERCENT = 15;

        /**
         * CORRIGIDO: Extrai texto recriando as linhas para que a busca funcione de forma confiável.
         */
        async function extractTextPerPage(file, headerOnly) {
            const pdf = await pdfjsLib.getDocument(URL.createObjectURL(file)).promise;
            const numPages = pdf.numPages;
            const pagesText = [];
            logOutput.textContent += `\n- Total de páginas detectadas: ${numPages}`;
            for (let i = 1; i <= numPages; i++) {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1 });
                const textContent = await page.getTextContent();

                let allItems = textContent.items;
                if (headerOnly) {
                    const headerTop = viewport.height * (1 - HEADER_BOTTOM_Y_PERCENT / 100);
                    allItems = allItems.filter(item => item.transform[5] >= headerTop);
                }
                if (allItems.length === 0) {
                    pagesText.push("");
                    continue;
                }
                allItems.sort((a, b) => {
                    if (Math.abs(a.transform[5] - b.transform[5]) < 2) {
                        return a.transform[4] - b.transform[4];
                    }
                    return b.transform[5] - a.transform[5];
                });
                let fullText = '';
                if(allItems.length > 0) {
                    let lastY = allItems[0].transform[5];
                    for (const item of allItems) {
                        if (Math.abs(item.transform[5] - lastY) > 5) {
                            fullText += '\n';
                        }
                        fullText += item.str;
                        lastY = item.transform[5];
                    }
                }
                pagesText.push(fullText);
            }
            return pagesText;
        }

        function buildPattern(labelsString) {
            const labels = labelsString.split(',').map(l => l.trim()).filter(Boolean);
            const pattern = `(?:${labels.map(l => l.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')).join('|')})\\s*([^\\n\\r]+)`;
            return { regex: new RegExp(pattern, 'g'), labels };
        }

        function detectRuns(pagesText, pattern) {
            const runs = [];
            let lastRun = null;
            pagesText.forEach((text, pageIndex) => {
                const matches = [...text.matchAll(pattern)];
                if (matches.length > 0) {
                    const key = matches[0][1].trim();
                    if (lastRun) {
                        lastRun.end = pageIndex;
                    }
                    lastRun = { key, start: pageIndex + 1, end: 0 };
                    runs.push(lastRun);
                }
            });
            if (lastRun) {
                lastRun.end = pagesText.length;
            }
            for(let i = 0; i < runs.length - 1; i++) {
                runs[i].end = runs[i+1].start - 1;
            }
            return runs;
        }

        function mergeByKey(runs) {
            const merged = new Map();
            runs.forEach(run => {
                if (!merged.has(run.key)) {
                    merged.set(run.key, []);
                }
                const pages = merged.get(run.key);
                for (let i = run.start; i <= run.end; i++) {
                    pages.push(i);
                }
            });
            return merged;
        }

        async function splitAndDownload(originalPdfFile, mergedRuns) {
            const { PDFDocument } = PDFLib;
            const originalPdfBytes = await originalPdfFile.arrayBuffer();

            logOutput.textContent += '\n\nIniciando geração dos PDFs...';
            for (const [key, pages] of mergedRuns.entries()) {
                const pdfDoc = await PDFDocument.create();
                const sourcePdfDoc = await PDFDocument.load(originalPdfBytes);

                const pageIndices = pages.map(p => p - 1);
                const copiedPages = await pdfDoc.copyPages(sourcePdfDoc, pageIndices);
                copiedPages.forEach(page => pdfDoc.addPage(page));
                const pdfBytes = await pdfDoc.save();

                const sanitizedKey = key.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
                const originalName = originalPdfFile.name.replace(/\.pdf$/i, '');
                const newFileName = `${originalName}_${sanitizedKey || 'sem_nome'}.pdf`;
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = newFileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                logOutput.textContent += `\n- PDF gerado: ${newFileName}`;
            }
            logOutput.textContent += '\n\nProcesso concluído!';
        }

        processBtn.addEventListener('click', async () => {
            const file = pdfFileInput.files[0];
            const labelsString = labelsInput.value;
            if (!file || !labelsString) {
                alert('Por favor, selecione um arquivo PDF e insira os rótulos.');
                return;
            }
            loader.style.display = 'block';
            processBtn.disabled = true;
            logOutput.textContent = 'Iniciando processamento...';

            try {
                const { regex, labels } = buildPattern(labelsString);
                logOutput.textContent += `\nRótulos de busca: ${labels.join(', ')}`;
                const pagesText = await extractTextPerPage(file, headerOnlyCheckbox.checked);
                const runs = detectRuns(pagesText, regex);
                if (runs.length === 0) {
                    logOutput.textContent += '\n\nNenhum rótulo/nome encontrado no documento.';
                    return;
                }
                logOutput.textContent += `\n\n--- Ocorrências Detectadas ---`;
                runs.forEach(run => {
                    logOutput.textContent += `\n- Nome: "${run.key}", Páginas: ${run.start}-${run.end}`;
                });

                const mergedRuns = mergeByKey(runs);
                logOutput.textContent += `\n\n--- Nomes Agrupados para Exportação ---`;
                mergedRuns.forEach((pages, key) => {
                    logOutput.textContent += `\n- ${key} (Total de ${pages.length} páginas)`;
                });

                await splitAndDownload(file, mergedRuns);
            } catch (error) {
                console.error('Erro durante o processamento:', error);
                logOutput.textContent += `\n\nERRO: ${error.message}`;
            } finally {
                loader.style.display = 'none';
                processBtn.disabled = false;
            }
        });
    </script>
</body>
</html>